# 헤드퍼스트 디자인패턴 두번째 이야기

## 1. 알고리즘 캡슐화(algorithm encapsulation)

컴퓨터 프로그래밍에서 **알고리즘(algorithm)** 은 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법을 의미한다.
알고리즘의 효율성 측정은 두 복잡도로 측정하는데 얼마나 빨리 실행되는지, 메모리를 얼마나 사용하는지에 따라 평가된다.

- 시간 복잡도(Time Complexity): 알고리즘이 완료되는데 걸리는 시간(연산 횟수)을 측정
- 공간 복잡도(Space Complexity): 알고리즘 실행 시 필요한 메모리 공간을 측정

보통 많이 하는 비유를 들자면 요리법과 같다. 이는 이전 서술 했던 디자인 패턴 ① 전략 패턴과는 조금 다르게 봐야할 부분이다.
알고리즘이 한 요리의 레시피라면 전략패턴은 파인 다이닝에서 설계하는 코스 전체를 설계하는 것, 청사진이라 볼 수 있다.  
***물론 전략패턴에서 찾아 볼 수 있는 개념 범주안에 알고리즘 캡슐화가 포함된다고 본다***

**캡슐화(Encapsulation)** 는 데이터와 그것을 처리하는 메소드를 하나로 묶는 것을 의미한다고 볼 수 있다.

- 데이터와 메서드의 결합: 객체의 **속성(Data field)** 과 그것을 처리하는 **행위(Method)** 를 클래스로 묶는다.
- 은닉: 객체의 실제 구현 내용이나 내부 데이터를 외부로부터 은닉하고, 인터페이스를 통해서만 접근 할 수 있다.

### 왜 알고리즘을 캡슐화 하는가?

- 교체 가능성(Interchangeability): 동일한 목적을 가진 두개 이상의 알고리즘을 동일한 인터페이스로 캡슐화 하면, 상황에 따라 알고리즘을 쉽게 갈아 끼울 수 있다. 8장의 서두에서의 스토리를 보면 ***커피와 홍차만들기*** 가 예시로 나오는데 제조 방법을 알고리즘으로 보고 공통되는 제조 단계를 뼈대화 하여 캡슐화 하는 것이 그 예가 될 수 있다.

## 2. 디자인 패턴 ② Template Method Pattern

그렇다면 템플릿 메소드 패턴에서는 알고리즘 캡슐화가 어떻게 적용될지 알아보자.

> ## 템플릿 메소드 패턴(Template Method Pattern)
>
> 템플릿 메소드 패턴은 알고리즘의 골격을 정의하되
> 템플릿 메소드를 사용하면 알고리즘의 일부 단계를 서브클래스에서 구현할 수 있으며, 알고리즘의 구조는 그대로 유지하면서 알고리즘의 특정 단계를 서브클래스에서 재정의(오버라이드) 할 수도 있다.

### # 데이터 마이닝 앱에서의 템플릿 메소드

1. 데이터 마이닝 앱은 데이터의 소스가 다르지만, 그 파일을 읽어서 처리한다는 처리과정은 일련의 과정으로 그 틀이 동일하다. 그 과정을 템플릿 메소드 패턴으로 구현한다. 파일에서 데이터를 추출하고 그것을 구조화 된 데이터로 변환하고 이를 저장하는 단계로 구성한다.

2. **[파일 열기 ‣ 데이터 추출 ‣ 데이터 변환 ‣ 결과 저장 ‣ 파일 닫기]** 라는 일련의 과정을 거친다고 가정한다. (파일 열기와 파일 닫기는 알고리즘 성립 조건에 따라 입력과 유한성이 있어야 하기에)

3. 여기서는 먼저 2개의 PDF와 CSV 처리만 가능하다고 가정한다.

### # 설계

1. 템플릿 클래스 정의: 알고리즘의 틀을 구축한다. 아래 코드에서는 `analyze_docs` 이 템플릿 메소드이다.

```python
from abc import ABC, abstractmethod

class Analyzer(ABC):

    # 템플릿 메소드: 데이터 마이닝 단계
    # open_file, save_result, close_file의 단계는 파일 형식이 서로 상이해도 같은 단계를 거친다.
    # extract_data, parsing_data의 과정은 파일 형식별로 서로 다른 방법을 사용한다.
    def analyze_docs(self, path):
        self.path = path
        self.open_file(path)
        # 데이터 추출과 분석을 strategy pattern: "핵심과정"이라는 인터페이스로? 할 필요는 있을까?
        data = self.extract_data()
        results = self.parsing_data(data)
        self.save_result(results)
        self.close_file()

    def opne_file(self, path):
        print(f"{path}경로의 파일을 열었습니다.")

    def save_result(self, result):
        print(f"분석 결과: {result}")

    def close_file(self):
        print("파일을 닫았습니다.")

    # 문서의 형식에 따라 각각 서로 다르게 구현해야 할 부분

    ## 데이터 추출
    @abstractmethod
    def extract_data(self):
        paas

    ## 데이터 분석
    @abstractmethod
    def parsing_data(self, data):
        pass
```

2. 데이터 유형(PDF, CSV)에 따른 구체적 구현

- 유형별 클래스

```python
from langchain_community.document_loaders import PyPDFLoader
import pandas as pd

class PDFDataExtractor(Analyzer):
    def extract_data(self):
        loader = PyPDFLoader(self.path)
        return loader.load()

    def parsing_data(self, data):
        return f"PDF 문서 {len(data)}페이지 분석 완료"

class CSVDataExtractor(Analyzer):
    def extract_data(self):
        return pd.read_csv(self.path)

    def parsing_data(self, data):
        return f"CSV 데이터 {len(data)}행 분석 완료"

```

## 3. 학습 회고

템플릿 메소드 패턴을 학습하면서 이전에 배운 전략 패턴과 무엇이 다른지 다소 혼란스러웠다.
두 가지 모두 "알고리즘을 캡슐화"한다는것 같은데 왜 서로 다른 패턴으로 존재하는지 의문이었다.

커피와 홍차 예문을 보면서도 전략 패턴으로 할 수 있는 것 같다는 생각이 들었다.

나름 비교한 내용은

- 전략 패턴은 알고리즘 전체 자체를 교체하는것이고,
- 템플릿 메소드 패턴은 알고리즘의 구조는 유지하되 일부 단계만 변경하는 것이라고 생각되었다.

템플릿 메서드 패턴은 해석해보면 부모가 가진 알고리즘 뼈대를 물려받은(상속하는) 자식클래스 관계인 것이다.

- 자식 클래스는 부모 클래스의 일종이다(IS-A)

전략 패턴의 가지고 있다(HAS-A)와는 다르다. 전략 패턴에서는 자식 클래스는 부모 클래스의 자식이 아닌 부품일 뿐이다.

`실제 프로젝트를 설계할때 적재적소에 어떠한 패턴을 적용하는 것이 효율적인지를 판단하는 시각을 기르고 싶다`
