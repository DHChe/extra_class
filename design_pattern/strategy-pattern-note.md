# **Strategy Pattern**

### 1. OOP(Object-oriented programming)

OOP는 객체 지향 프로그래밍으로 객체 개념을 기반으로 하는 컴퓨터 프로그래밍의 패러다임이다. 

컴퓨터 프로그래밍에서 작게 구분하는 단위는 **클래스**이고, 이러한 클래스를 활용해 코딩을 하는 것을 **객체 지향형 프로그래밍**이라고 한다. 

즉 클래스는 객체를 생성하기 위한 템플릿의 역할을 한다.


>### Class / Object / Method

- 클래스는 같은 종류(또는 문제해결을 위한) 집단에 속하는 속성(**attribute**)과 행위(**behavior**)를 정의한것


- 객체는 클래스의 인스턴스(실제로 메모리상에 할당된 것)이다. 객체는 자기자신의 고유의 속성(**attribute**)을 가지고 클래스에서 정의한 행위(**behavior**)를 할 수 있다.
    - 이때 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용

- 메서드는 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 메세지


> ### OOP의 요소
1. `캡슐화 (Encapsulation)`: 객체의 속성(***data field***)과 행위(***method***)를 하나로 묶고, 실제 구현 내용일부를 내부에 감추어 은닉한다.
- 객체를 외부에서 수정하지 못하게 하여 데이터의 ***무결성***을 보장한다. 
- 내부 로직이 변경되어도 외부 코드에는 영향을 주지 않아 low coupling 효과가 있다.

2. `추상화 (Abstraction)`: 사용자에게 필요한 핵심 인터페이스(기능)만을 추출하여 정의하는 과정
- 복잡성을 낮추어 사용자가 **어떻게**가 아닌 **무엇을** 하는지에 집중하게 하여 ***설계의 명확성***을 높임

3. `상속 (Inheritance)`: superClass의 특성과 기능을 물려받아 새로운 subClass를 생성하는것
- 공통된 로직은 superClass에게 집중시켜 **코드 재사용성**을 극대화

4. `다형성 (Polyporphism)`: 하나의 인터페이스, 클래스가 객체로 동작할 수 있는 능력
- 오버라이딩, 오버로딩을 통해 구현되며 구체적 타입에 의존하지 않고 추상적 타입에 의존하여 유연성과 확장성을 향상시킴
---

### 2. 문제의 발단(오리 시뮬레이션 게임)

#### 2.1 초기 설계
➡️ 초기 설계는 단순한 상속에서 시작  
```python
class Ducks:
    # 오리가 가지는 기본적 행동
    def quack(self):
        print("꽥")

    def swim(self):
        print("물위에서 떠다니며 수영합니다.")

    # 오리마다 외형이 다르므로 상속받는 서브클래스에서 직접구현하도록 하는 추상화
    def appearance(self):
        pass
```
```python
# 서브 클래스(청둥오리, 빨간머리오리)
# Ducks 슈퍼클래스를 상속하므로 기본적으로 quack, swim을 물려받음
class MallardDuck(Duck):
    
    # 추상화를 개별적으로 구현
    def appearance(self):
        print("귀엽게 생긴 청둥오리입니다.")

class RedheadDuck(self):
    def appearance(self):
        print("무섭게 생긴 빨간머리오리입니다.")
```
#### 2.2 새로운 요청사항
➡️ 새로운 요청사항(behavior) 발생
```python
class Ducks:
    # 오리가 가지는 기본적 행동
    def quack(self):
        print("꽥")

    def swim(self):
        print("물위에서 떠다니며 수영합니다.")

    # 오리마다 외형이 다르므로 상속받는 서브클래스에서 직접구현하도록 하는 추상화
    def appearance(self):
```










